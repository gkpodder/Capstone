\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage[utf8]{inputenc}


\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\wss{Fill in your project name and description}

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{...}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The \textbf{Proxi}, is decomposed into a hierarchy of modules following the 
design principles of information hiding and separation of concerns. Each 
module corresponds to a well-defined secret and is independently assignable 
to a developer. The decomposition balances hardware hiding, behaviour 
hiding, and software decision modules.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{0.3\textwidth} p{0.65\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2 Modules (Secrets / Responsibilities)}\\
\midrule

\multirow{2}{*}{\textbf{Hardware-Hiding}} &
\textbf{HH-IO (Audio Adapter)} – manages microphone input and audio 
output across different platforms.\\
& \textbf{HH-Auto (System Control)} – performs basic desktop actions 
such as typing, clicking, or launching applications.\\
\midrule

\multirow{7}{*}{\textbf{Behaviour-Hiding}} &
\textbf{BH-Input (Voice \& Text Manager)} – captures user input, 
converts speech to text, and normalizes text commands. Implements 
\textit{FUNC.R.1–R.2}.\\
& \textbf{BH-NLU (Intent Parser)} – interprets text into structured 
intents and parameters based on defined command patterns. Implements 
\textit{FUNC.R.3}.\\
& \textbf{BH-Plan (Task Executor)} – determines which agent or tool 
should handle a command and coordinates its execution. Implements 
\textit{FUNC.R.4}.\\
& \textbf{BH-Safety (Confirmation Gate)} – validates actions that may 
affect files or system settings and requests confirmation. Implements 
\textit{FUNC.R.9}.\\
& \textbf{BH-Session (Context Manager)} – maintains user session data, 
history, and undo information for continuity. Supports 
\textit{FUNC.R.4}.\\
& \textbf{BH-Feedback (Response Manager)} – converts textual responses 
into spoken or visual feedback for the user. Implements 
\textit{FUNC.R.5–R.6}.\\
& \textbf{BH-UI (Proxi Interface)} – presents status updates, 
confirmations, and results; supports full voice-only interaction. 
Implements \textit{FUNC.R.8}.\\
\midrule

\multirow{5}{*}{\textbf{Software-Decision}} &
\textbf{SD-Types (Core Structures)} – defines abstract data types for 
Command, Intent, and Plan.\\
& \textbf{SD-ToolRegistry (Action Map)} – maintains the mapping between 
recognized intents and available system actions.\\
& \textbf{SD-Store (Local Storage)} – handles persistent storage for 
user preferences, session history, and logs.\\
& \textbf{SD-STT/TTS Config} – specifies configuration for speech and 
text synthesis models and supported languages.\\
& \textbf{SD-Log (Event Logger)} – records system actions and feedback 
events for debugging and validation.\\
\bottomrule
\end{tabular}
\caption{Module Hierarchy for Proxi Voice Assistant}
\label{TblMH}
\end{table}


\textbf{Likely Changes:}
\begin{itemize}
  \item The choice of speech recognition or text-to-speech library 
  (for example, switching from Whisper API to a local model).
  \item Adjustments to the user interface layout or how voice commands 
  trigger visible feedback or audio playback.
  \item Fine-tuning thresholds for speech detection and timing between 
  input and response based on user testing.
  \item Updating supported voice commands or adding new MCP tools as 
  features are expanded.
\end{itemize}

\textbf{Unlikely Changes:}
\begin{itemize}
  \item The main processing loop of Input $\rightarrow$ Interpret 
  $\rightarrow$ Plan $\rightarrow$ Execute $\rightarrow$ Feedback.
  \item The core data structures used for storing Commands, Intents, 
  and Action Plans.
  \item The communication pattern between modules through the MCP 
  agent interface.
\end{itemize}

\textbf{Traceability to SRS:}
\begin{itemize}
  \item \textbf{BH-Input} fulfills \textit{FUNC.R.1–R.2}: speech and text 
  input handling with accuracy $\geq 90\%$.
  \item \textbf{BH-NLU} fulfills \textit{FUNC.R.3}: intent recognition 
  accuracy $\geq 90\%$.
  \item \textbf{BH-Plan} fulfills \textit{FUNC.R.4}: agent planning and 
  execution success rate $\geq 85\%$.
  \item \textbf{BH-Feedback} fulfills \textit{FUNC.R.5–R.6}: provides 
  feedback and spoken confirmation within response time $\leq 2\,\text{s}$.
  \item \textbf{BH-UI} fulfills \textit{FUNC.R.8}: supports full hands-free 
  operation for accessibility.
  \item \textbf{BH-Safety} fulfills \textit{FUNC.R.9}: requests confirmation 
  before executing high-risk or destructive actions.
  \item \textbf{Support modules (SD, HH)} enable non-functional goals on 
  latency, reliability, and auditability through structured logging.
\end{itemize}

\newpage

\section{MIS of HH-IO (Audio Adapter)} \label{mod:HHIO}

\subsection{Module}

HH-IO (Audio Adapter)

\subsection{Uses}

System audio interface

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
openMic & N/A & N/A & MicNotFound \\
closeMic & N/A & N/A & CloseFailed \\
recordAudio & seconds: real & sound: AudioStream & RecordFailed \\
playAudio & sound: AudioStream & N/A & PlaybackFailed \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item micOpen : Boolean
  \item lastSignal : AudioStream
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item micDevice : physical microphone
  \item speakerDevice : physical speaker or headset
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item At least one working microphone and speaker device exists.
  \item Only one module controls the microphone at a time.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{openMic}():
\begin{itemize}
  \item transition: micOpen := true if micDevice is available.
  \item exception: MicNotFound if micDevice is missing or busy.
\end{itemize}

\noindent
\textbf{closeMic}():
\begin{itemize}
  \item transition: micOpen := false if open.
  \item exception: CloseFailed if device cannot close.
\end{itemize}

\noindent
\textbf{recordAudio}(seconds):
\begin{itemize}
  \item output: returns AudioStream of given duration.
  \item transition: lastSignal := captured audio.
  \item exception: RecordFailed if capture fails or micOpen = false.
\end{itemize}

\noindent
\textbf{playAudio}(sound):
\begin{itemize}
  \item transition: lastSignal := sound.
  \item output: sound played through speakerDevice.
  \item exception: PlaybackFailed if playback fails.
\end{itemize}

\subsubsection{Local Functions}

None.

\section{MIS of HH-Auto (System Control)} \label{mod:HHAuto}

\subsection{Module}

HH-Auto (System Control)

\subsection{Uses}

Operating system automation interface

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
moveCursor & p: ScreenPos & N/A & ActionError \\
leftClick & N/A & N/A & ActionError \\
typeText & t: String & N/A & ActionError \\
openApp & id: AppId & N/A & ActionError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item currentPos : ScreenPos
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item desktopEnv : user desktop environment
  \item keyboardDevice : keyboard input channel
  \item pointingDevice : mouse or trackpad
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item The user session allows simulated input events.
  \item Screen coordinates are valid for the active display.
  \item AppId refers to an installed and accessible application.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{moveCursor}(p):
\begin{itemize}
  \item transition: currentPos := p.
  \item output: N/A.
  \item exception: ActionError if cursor move fails.
\end{itemize}

\noindent
\textbf{leftClick}():
\begin{itemize}
  \item transition: none.
  \item output: N/A.
  \item exception: ActionError if click event fails.
\end{itemize}

\noindent
\textbf{typeText}(t):
\begin{itemize}
  \item transition: none.
  \item output: N/A.
  \item exception: ActionError if key input fails.
\end{itemize}

\noindent
\textbf{openApp}(id):
\begin{itemize}
  \item transition: none.
  \item output: N/A.
  \item exception: ActionError if app launch fails.
\end{itemize}

\subsubsection{Local Functions}

None.

\section{MIS of BH-Input (Voice \& Text Manager)} \label{mod:BHInput}

\subsection{Module}

BH-Input (Voice \& Text Manager)

\subsection{Uses}

HH-IO, SD-STT/TTS Config, SD-Types, SD-Log

\subsection{Syntax}

\subsubsection{Exported Constants}

None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
startCapture & mode: InputMode & N/A &
MicUnavailable, AlreadyCapturing \\
stopCapture & N/A & N/A & NotCapturing \\
getLastText & N/A & text: String & NoInputAvailable \\
getStatus & N/A & s: InputStatus & N/A \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item inputState : InputState
  \item currentMode : InputMode
  \item lastText : String
  \item partialText : String
  \item lastError : InputError or null
\end{itemize}

InputState = \{Idle, Listening, Processing\}

InputMode = \{VoiceOnly, TextOnly, Mixed\}

InputStatus is a record:
\begin{itemize}
  \item state : InputState
  \item hasText : Boolean
  \item hasError : Boolean
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item micStream : handled by HH-IO for live audio
  \item sttService : speech-to-text service
  \item now : system clock for timing
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item The microphone and STT component are available when started.
  \item Only one capture session runs at a time.
  \item Calling modules handle all exceptions raised.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{startCapture}(mode):
\begin{itemize}
  \item transition: if inputState = Idle and micStream ready then
  \[
    inputState := Listening, \quad currentMode := mode, \quad
    partialText := ""
  \]
  \item exception: MicUnavailable if device fails, AlreadyCapturing if
  inputState $\neq$ Idle.
\end{itemize}

\noindent
\textbf{stopCapture}():
\begin{itemize}
  \item transition: if inputState $\neq$ Idle then inputState := Idle.
  \item exception: NotCapturing if inputState = Idle.
\end{itemize}

\noindent
\textbf{getLastText}():
\begin{itemize}
  \item output: returns lastText if not empty.
  \item exception: NoInputAvailable if lastText is empty.
\end{itemize}

\noindent
\textbf{getStatus}():
\begin{itemize}
  \item output: returns a record s with
  $s.state = inputState$, $s.hasText = (lastText \neq "")$,
  $s.hasError = (lastError \neq null)$.
\end{itemize}

\subsubsection{Local Functions}

Let Event = \{StartCmd, StopCmd, Chunk, Error, Timeout\}

\noindent
$nextState : InputState \times Event \rightarrow InputState$

\[
  nextState(s, e) =
  \begin{cases}
    Listening & \text{if } s = Idle \land e = StartCmd\\
    Idle & \text{if } s = Listening \land e = StopCmd\\
    Processing & \text{if } s = Listening \land e = Chunk\\
    Processing & \text{if } s = Processing \land e = Chunk\\
    Idle & \text{if } e = Error \lor e = Timeout\\
    s & \text{otherwise}
  \end{cases}
\]

During execution BH-Input updates
\[
  inputState := nextState(inputState, e)
\]
for each event e. When transcription ends, partialText moves into
lastText.

\section{MIS of BH-NLU (Intent Parser)} \label{mod:BHNlu}

\subsection{Module}

BH-NLU (Intent Parser)

\subsection{Uses}

SD-Types, SD-Log

\subsection{Syntax}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
parseText & text: String & i: Intent & ParseError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

\begin{itemize}
  \item Input text is in English and grammatically valid.
  \item Command patterns are defined in SD-Types.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{parseText}(text):
\begin{itemize}
  \item output: produces an Intent record with fields
  \[
    i.type = detectCommand(text), \quad
    i.params = extractParams(text)
  \]
  \item exception: ParseError if text cannot be matched to any pattern.
\end{itemize}

\subsubsection{Local Functions}

\[
  detectCommand : String \rightarrow IntentType
\]
\[
  extractParams : String \rightarrow ParamSet
\]


\section{MIS of BH-Plan (Task Executor)} \label{mod:BHPlan}

\subsection{Module}

BH-Plan (Task Executor)

\subsection{Uses}

BH-NLU, SD-ToolRegistry, SD-Types, SD-Log, HH-Auto

\subsection{Syntax}

\subsubsection{Exported Constants}

ExecStatus = \{Pending, Success, Failed\}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.3cm} p{4cm} p{4cm} p{2.3cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
planAction & i: Intent & p: Plan & NoToolFound \\
executePlan & p: Plan & s: ExecStatus & ExecError \\
cancelPlan & N/A & N/A & NoPendingPlan \\
getLastStatus & N/A & s: ExecStatus & N/A \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item currentPlan : Plan or null
  \item lastStatus : ExecStatus
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item toolSet : accessible system tools or MCP agents
  \item now : system clock for execution timing
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item The input intent has been validated by BH-NLU.
  \item Each available tool in SD-ToolRegistry exposes a run() routine.
  \item MCP agents or automation tools are reachable when requested.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{planAction}(i):
\begin{itemize}
  \item output: generates a Plan record p with:
  \[
    p.tool = matchTool(i.type), \quad
    p.parameters = i.params, \quad
    p.time = now
  \]
  \item transition: currentPlan := p.
  \item exception: NoToolFound if matchTool fails.
\end{itemize}

\noindent
\textbf{executePlan}(p):
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item currentPlan := p.
    \item s := runTool(p.tool, p.parameters).
  \end{itemize}
  \item output: returns s of type ExecStatus.
  \item exception: ExecError if runTool fails.
\end{itemize}

\noindent
\textbf{cancelPlan}():
\begin{itemize}
  \item transition: currentPlan := null, lastStatus := Failed.
  \item exception: NoPendingPlan if currentPlan = null.
\end{itemize}

\noindent
\textbf{getLastStatus}():
\begin{itemize}
  \item output: returns lastStatus.
  \item transition: none.
\end{itemize}

\subsubsection{Planning Logic}

To model the planning stage, define:
\[
  matchTool : IntentType \rightarrow ToolId
\]

\[
  runTool : ToolId \times ParamSet \rightarrow ExecStatus
\]

The planning decision can be expressed as:

\[
  planAction(i) =
  \begin{cases}
    p = (matchTool(i.type), i.params, now) &
    \text{if a tool exists for } i.type \\
    \text{NoToolFound error} &
    \text{otherwise}
  \end{cases}
\]

Execution behaviour follows:
\[
  executePlan(p) =
  \begin{cases}
    Success & \text{if runTool(p.tool, p.parameters) = true}\\
    Failed & \text{otherwise}
  \end{cases}
\]

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{matchTool}(t): searches SD-ToolRegistry for a matching tool.
  \item \textbf{runTool}(id, params): calls the linked MCP or system command.
\end{itemize}

\section{MIS of BH-Safety (Confirmation Gate)} \label{mod:BHSafety}

\subsection{Module}

BH-Safety (Confirmation Gate)

\subsection{Uses}

BH-UI, SD-Types, SD-Log

\subsection{Syntax}

\subsubsection{Exported Constants}

RiskLevel = {Low, Medium, High}

\noindent SafetyDecision = {AutoAllow, AskUser, Block}

\noindent ApprovalResult = {Approved, Denied, Cancelled}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.3cm} p{4cm} p{4cm} p{2.3cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
classifyAction & a: Action & r: RiskLevel & N/A \\
decidePolicy & a: Action & d: SafetyDecision & N/A \\
confirmAction & a: Action & res: ApprovalResult & UserTimeout \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item pendingAction : Action or null
  \item lastDecision : SafetyDecision or null
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item uiChannel : connection to BH-UI for user prompts
  \item now : system clock for time limits
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item BH-UI can show a yes/no prompt and return a user response.
  \item Every Action record includes a defined riskLevel field.
  \item The system clock is monotonic for timeout checks.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{classifyAction}(a):
\begin{itemize}
  \item output: returns a.riskLevel.
  \item transition: none.
\end{itemize}

\noindent
\textbf{decidePolicy}(a):
\begin{itemize}
  \item output: returns d of type SafetyDecision, where
  \[
    d =
    \begin{cases}
      AutoAllow & \text{if } a.riskLevel = Low\\
      AskUser & \text{if } a.riskLevel = Medium\\
      Block & \text{if } a.riskLevel = High \land a.isIrreversible\\
      AskUser & \text{if } a.riskLevel = High \land \neg a.isIrreversible
    \end{cases}
  \]
  \item transition: lastDecision := d.
\end{itemize}

\noindent
\textbf{confirmAction}(a):
\begin{itemize}
  \item transition: pendingAction := a.
  \item output:
  \begin{itemize}
    \item If decidePolicy(a)=AutoAllow then res=Approved.
    \item If decidePolicy(a)=Block then res=Denied.
    \item If AskUser then BH-UI prompts user; waits for yes/no.
  \end{itemize}
  \item exception: UserTimeout if no answer before time limit.
\end{itemize}

\subsubsection{Risk Policy Table}

\begin{center}
\begin{tabular}{p{2cm} p{3cm} p{3cm} p{3cm}}
\toprule
\textbf{Risk} & \textbf{Irreversible?} & \textbf{Decision} & \textbf{Example} \\
\midrule
Low & N/A & AutoAllow & Open folder, read file \\
Medium & N/A & AskUser & Rename or move file \\
High & false & AskUser & Delete to recycle bin \\
High & true & Block & Permanently delete data \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Local Functions}

\[
  policy : RiskLevel \times Bool \rightarrow SafetyDecision
\]

\[
  policy(r, irr) =
  \begin{cases}
    AutoAllow & \text{if } r = Low\\
    AskUser & \text{if } r = Medium\\
    Block & \text{if } r = High \land irr = true\\
    AskUser & \text{if } r = High \land irr = false
  \end{cases}
\]

\noindent
decidePolicy(a) = policy(a.riskLevel, a.isIrreversible)

\noindent
This module fulfills \textit{FUNC.R.9} by ensuring confirmation or
blocking of high-risk actions, reducing hazards identified in the
safety analysis.


\section{MIS of BH-Feedback (Response Manager)} \label{mod:BHFeedback}

\subsection{Module}

BH-Feedback (Response Manager)

\subsection{Uses}

HH-IO, SD-STT/TTS Config, SD-Types, SD-Log

\subsection{Syntax}

\subsubsection{Exported Constants}

OutputMode = \{VoiceOnly, TextOnly, Both\}

\noindent FeedbackStatus = \{Idle, Speaking, Completed, Failed\}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
queueMessage & msg: String, m: OutputMode & N/A & QueueFull \\
speakNow & msg: String, m: OutputMode & s: FeedbackStatus &
TtsError \\
getLastStatus & N/A & s: FeedbackStatus & N/A \\
cancelAll & N/A & N/A & N/A \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item outputQueue : sequence of (String, OutputMode)
  \item lastStatus : FeedbackStatus
  \item isSpeaking : Boolean
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item audioOut : speaker connection through HH-IO
  \item ttsService : text-to-speech component
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item ttsService can turn any short message into speech in less than
  the required response time from the SRS.
  \item HH-IO can play audio without blocking the whole system.
  \item The output queue has a fixed maximum size.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{queueMessage}(msg, m):
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item If the queue is not full then append (msg, m) to outputQueue.
  \end{itemize}
  \item output: N/A.
  \item exception: QueueFull if appending would exceed the limit.
\end{itemize}

\noindent
\textbf{speakNow}(msg, m):
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item isSpeaking := true; lastStatus := Speaking.
    \item If m = VoiceOnly or m = Both then send msg to ttsService and
    play through audioOut.
    \item If m = TextOnly or m = Both then write msg to the log or UI
    channel.
  \end{itemize}
  \item output:
  \begin{itemize}
    \item If playback and any text output succeed then lastStatus :=
    Completed and s = Completed.
    \item Otherwise lastStatus := Failed and s = Failed.
  \end{itemize}
  \item exception: TtsError if ttsService cannot produce speech.
\end{itemize}

\noindent
\textbf{getLastStatus}():
\begin{itemize}
  \item output: returns lastStatus.
  \item transition: none.
\end{itemize}

\noindent
\textbf{cancelAll}():
\begin{itemize}
  \item transition: clear outputQueue; isSpeaking := false;
  lastStatus := Idle.
  \item output: N/A.
  \item exception: N/A.
\end{itemize}

\subsubsection{Local Functions}

\noindent
We model the processing of the queue with a helper function:

\[
  nextMessage : \text{sequence of (String, OutputMode)} \rightarrow
  (String, OutputMode) \cup \{\text{None}\}
\]

\[
  nextMessage(q) =
  \begin{cases}
    \text{first element of } q & \text{if } q \neq []\\
    \text{None} & \text{if } q = []
  \end{cases}
\]

\noindent
BH-Feedback periodically checks outputQueue. If nextMessage returns a
pair (msg, m), it behaves as in speakNow(msg, m) and then removes that
entry from the queue. If None, it leaves the state unchanged.

\noindent
This module fulfills \textit{FUNC.R.5–R.6} by providing timely spoken
and visual feedback to the user, and by reporting a clear status that
can be logged or shown in the interface.

\section{MIS of BH-UI (Proxi Interface)} \label{mod:BHUI}

\subsection{Module}

BH-UI (Proxi Interface)

\subsection{Uses}

BH-Feedback, BH-Safety, BH-Input, SD-Log, SD-Types

\subsection{Syntax}

\subsubsection{Exported Constants}

UIState = \{Idle, Listening, Waiting, Displaying, Error\}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2.5cm}}
\hline
\textbf{Name} & \textbf{Input} & \textbf{Output} & \textbf{Errors} \\
\hline
updateView & s: UIState & N/A & RenderError \\
showMessage & msg: String & N/A & RenderError \\
promptUser & q: String & ans: Bool & Timeout \\
showStatus & st: FeedbackStatus & N/A & N/A \\
clearScreen & N/A & N/A & N/A \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\begin{itemize}
  \item uiState : UIState
  \item lastMsg : String
  \item lastError : String or null
\end{itemize}

\subsubsection{Environment Variables}

\begin{itemize}
  \item display : visual interface (screen or console)
  \item micLED : visual cue showing listening status
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item Display device is available and writable.
  \item Voice cues or LEDs can toggle quickly without delay.
  \item Text is short enough to fit within screen limits.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent
\textbf{updateView}(s):
\begin{itemize}
  \item transition: uiState := s.
  \item output: updates micLED or text based on state.
  \item exception: RenderError if update fails.
\end{itemize}

\noindent
\textbf{showMessage}(msg):
\begin{itemize}
  \item transition: lastMsg := msg; uiState := Displaying.
  \item output: renders msg visually or as voice through BH-Feedback.
  \item exception: RenderError if display or output fails.
\end{itemize}

\noindent
\textbf{promptUser}(q):
\begin{itemize}
  \item transition: uiState := Waiting.
  \item output: shows q; waits for yes/no reply by voice or keypress.
  \item exception: Timeout if no input received in time limit.
\end{itemize}

\noindent
\textbf{showStatus}(st):
\begin{itemize}
  \item output: shows latest FeedbackStatus or progress.
  \item transition: none.
\end{itemize}

\noindent
\textbf{clearScreen}():
\begin{itemize}
  \item transition: uiState := Idle; lastMsg := "".
  \item output: clears visual area.
\end{itemize}

\subsubsection{Local Functions}

\noindent
We define a helper that maps states to display text:

\[
  stateText : UIState \rightarrow String
\]

\[
  stateText(s) =
  \begin{cases}
    "Listening..." & \text{if } s = Listening\\
    "Waiting for input..." & \text{if } s = Waiting\\
    "Processing..." & \text{if } s = Displaying\\
    "Idle" & \text{if } s = Idle\\
    "Error" & \text{if } s = Error
  \end{cases}
\]

\noindent
This mapping helps BH-Feedback and BH-Safety show consistent
notifications through both visual and voice channels.
This module fulfills \textit{FUNC.R.8} by ensuring full hands-free
interaction and clear accessibility feedback for all system states.



\newpage






\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}